#!/usr/bin/perl
#-----------------------------------------------------------------------
# cdump.pl : bulk dump of a site's content
#
# This program starts from a single section or page, and dumps it and 
# all of its contents.  The output is written in the form of a perl 
# script, which can be executed to re-import the data.  The database
# being dumped is taken from the local exsite.conf file;  if the output
# script is being executed, the database being imported into is taken 
# from the local exsite.conf file.  Thus, you simply need to copy the 
# output script to a new website's directory to import the data into a 
# different database.
#
# This program is run from the command line as follows:
#
# % cdump.pl section 99 > mydump.pl   # dumps a section
#
# % cdump.pl page 666 > mydump.pl     # dumps a page
#
#-----------------------------------------------------------------------
#
#   Copyright 2001-2004 Exware Solutions, Inc.  http://www.exware.com
#
#   This file is part of ExSite WebWare (ExSite, for short).
#
#   ExSite is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   ExSite is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ExSite; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#   Users requiring warranty coverage and/or support may arrange alternate
#   commercial licensing for ExSite, by contacting Exware Solutions 
#   via the website noted above.
#
#----------------------------------------------------------------------------

use strict;
use ExSite::Config;
use ExSite::Misc;
use ExSite::DB;

&exsite_init;
my $what = shift @ARGV;
my $id = shift @ARGV;
my %child = ( ""=>"section",
	      section=>"page", 
	      page=>"content", 
	      content=>"content_data",
	      content_data=>"" );
my %parent = reverse %child;
my ($section_id,$page_id,$content_id);

if ($what !~ /^(page|section)$/ || $id !~ /^\d+$/) {
    print "usage: cdump page|section N > dump.pl\n";
    exit 1;
}

my $db = new ExSite::DB;
my $dat = $db->fetch($what,$id);
if (! $dat) {
    print "cdump: $what $dat: not found\n";
    exit 2;
}

# preamble

print '#!/usr/bin/perl
# autogenerated by cdump.pl
use strict;
use ExSite::Config;
use ExSite::DB;
&exsite_init;
my $db = new ExSite::DB;
my ($section_id,$page_id,$content_id,$content_data_id);
';

my @pages;
if ($what eq "section") {
    $section_id = $dat->{section_id};
    &insert("section",$dat);
    @pages = $db->fetch_child("page","section",$section_id);
    print "
########################################################################
#
#  WARNING - the section template_id and parent_id may not be valid 
#  after reimporting.  Page template_id also may be invalid.
#
########################################################################

";
}
else {
    print "
########################################################################
#
#  WARNING - when dumping page data, the section_id and template_id
#  will often end up referencing inappropriate content, and should
#  be manually corrected if being re-imported elsewhere.
#
########################################################################

";
    @pages = ( $dat );
}

foreach my $page (@pages) {
    $page_id = $page->{page_id};
    &insert("page",$page);
    my @content = $db->fetch_child("content","page",$page_id);
    foreach my $content (@content) {
	$content_id = $content->{content_id};
	&insert("content",$content);
	my @cdata = $db->fetch_child("content_data","content",$content_id,"content_data_id");
	# only dump the most recent content
	if (@cdata > 0) {
	    &insert("content_data",$cdata[-1]);
	}
    }
}

sub insert {
    my ($table,$data) = @_;
    print "\$${table}_id = \$db->insert(\"$table\",{";
    my $pkey = $db->get_key($table);
    if ($pkey) {
	delete $data->{$pkey};
    }
    my $pref;
    if ($table eq "content_data") { delete $data->{ptime}; }
    if ($parent{$table}) {
	my $ref = $db->{map}->get_reference_column($table,$parent{$table});
	if ($ref) {
	    delete $data->{$ref};
	    $pref = "$ref=>\$".$parent{$table}."_id";
	}
    }
    while (my ($key,$val) = each %$data) {
	next if !defined $val;
	$val =~ s/([\$\"\@])/\\$1/gs;  # escape perl reserved chars
	$val =~ s/\r\n/\n/gs;        # convert cr-lfs to lfs
	$val =~ s/([\n\r])/\\n/gs;   # escape newlines
	print "$key=>\"$val\",";
    }
    print "$pref});\n";
}

